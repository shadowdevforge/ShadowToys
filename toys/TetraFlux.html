<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TetraFlux</title>
    <meta name="theme-color" content="#1e1e2e">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500;800&family=Inter:wght@400;600;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        :root {
            --ctp-base: #1e1e2e;
            --ctp-mantle: #181825;
            --ctp-surface0: #313244;
            --ctp-surface1: #45475a;
            --ctp-text: #cad3f5;
            --ctp-subtext: #a6adc8;
            --ctp-blue: #8aadf4;
            --ctp-red: #ed8796;
            --ctp-green: #a6da95;
            --ctp-yellow: #eed49f;
            --ctp-mauve: #cba6f7;
            --radius: 16px;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background: var(--ctp-base);
            color: var(--ctp-text);
            font-family: 'Inter', sans-serif;
            /* Critical for mobile: Uses dynamic viewport height */
            height: 100dvh; 
            width: 100vw;
            overflow: hidden;
            display: flex; 
            flex-direction: column;
        }

        /* --- LAYOUT CONTAINER --- */
        #game-layout {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            padding: 10px 16px 20px 16px; /* Bottom padding for safe area */
        }

        /* --- HUD (Top) --- */
        .hud {
            flex-shrink: 0; /* Prevent shrinking */
            display: flex; justify-content: space-between; align-items: flex-end;
            margin-bottom: 12px;
            padding: 0 4px;
        }
        
        .score-block { display: flex; flex-direction: column; }
        .label { font-size: 0.75rem; color: var(--ctp-subtext); font-weight: 700; letter-spacing: 1px; text-transform: uppercase; }
        .value { font-family: 'JetBrains Mono', monospace; font-size: 1.75rem; font-weight: 800; color: var(--ctp-text); line-height: 1; }
        .value.highlight { color: var(--ctp-yellow); text-shadow: 0 0 15px rgba(238, 212, 159, 0.2); }

        /* --- CANVAS AREA (Middle) --- */
        .viewport {
            flex: 1; /* Takes all remaining vertical space */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0; /* Important for flex child scrolling/resizing */
        }

        .canvas-frame {
            position: relative;
            background: var(--ctp-mantle);
            border: 2px solid var(--ctp-surface0);
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            /* Dimensions set by JS to maintain aspect ratio */
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* --- CONTROLS (Bottom) --- */
        .controls-area {
            flex-shrink: 0;
            margin-top: 16px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            height: 140px; /* Fixed control height */
        }

        .btn-ctrl {
            background: var(--ctp-surface0);
            border: none; border-radius: 12px;
            color: var(--ctp-text); font-size: 1.8rem;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: background 0.1s, transform 0.1s;
            box-shadow: 0 4px 0 var(--ctp-surface1);
            touch-action: manipulation;
        }
        .btn-ctrl:active { transform: translateY(4px); box-shadow: none; background: var(--ctp-surface1); }
        
        .btn-lg { 
            grid-column: span 3; 
            background: var(--ctp-mauve); 
            color: var(--ctp-base); 
            box-shadow: 0 4px 0 #b08add; 
            font-size: 1rem; 
            font-weight: 800; 
            letter-spacing: 1px;
        }
        .btn-lg:active { background: #b08add; }

        /* --- OVERLAYS --- */
        .overlay {
            position: absolute; inset: 0;
            background: rgba(30, 30, 46, 0.92);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }

        h1 { font-size: 2.5rem; font-weight: 900; margin: 0; letter-spacing: -2px; color: var(--ctp-mauve); text-align: center; line-height: 1; }
        .subtitle { color: var(--ctp-subtext); margin: 10px 0 30px; font-size: 0.9rem; text-align: center; }

        .menu-btn {
            background: var(--ctp-blue); color: var(--ctp-base);
            border: none; padding: 14px 32px; border-radius: 50px;
            font-size: 1rem; font-weight: 800; cursor: pointer;
            box-shadow: 0 8px 20px rgba(137, 180, 250, 0.3);
            transition: transform 0.1s;
        }
        .menu-btn:active { transform: scale(0.95); }

        .settings-row { margin-top: 24px; display: flex; gap: 24px; }
        .icon-toggle { font-size: 1.8rem; color: var(--ctp-surface1); cursor: pointer; transition: color 0.2s; }
        .icon-toggle.on { color: var(--ctp-green); }

        /* Desktop Adjustments */
        @media (min-width: 600px) {
            .controls-area { display: none; } 
            .canvas-frame { border-width: 4px; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
            h1 { font-size: 3.5rem; }
        }
    </style>
</head>
<body>

    <div id="game-layout">
        
        <!-- HUD -->
        <div class="hud">
            <div class="score-block">
                <div class="label">Score</div>
                <div class="value" id="score">0</div>
            </div>
            <div class="score-block" style="align-items: flex-end;">
                <div class="label">Best</div>
                <div class="value highlight" id="high-score">0</div>
            </div>
        </div>

        <!-- VIEWPORT -->
        <div class="viewport" id="viewport">
            <div class="canvas-frame" id="canvasFrame">
                <canvas id="gameCanvas"></canvas>
                
                <!-- START SCREEN -->
                <div id="start-screen" class="overlay active">
                    <h1>TETRA<br>FLUX</h1>
                    <p class="subtitle">Stack // Clear // Survive</p>
                    <button class="menu-btn" onclick="Game.start()">INITIALIZE</button>
                    <div class="settings-row">
                        <i class="ph-fill ph-speaker-high icon-toggle on" id="btn-sfx" onclick="AudioSys.toggle()"></i>
                        <i class="ph-fill ph-vibrate icon-toggle on" id="btn-vib" onclick="Game.toggleVib()"></i>
                    </div>
                </div>

                <!-- GAME OVER -->
                <div id="game-over" class="overlay">
                    <h1 style="color:var(--ctp-red)">SYSTEM<br>HALTED</h1>
                    <p class="subtitle">Overflow Detected</p>
                    <div class="value" id="final-score" style="margin-bottom:20px; font-size:2.5rem;">0</div>
                    <button class="menu-btn" style="background:var(--ctp-red)" onclick="Game.start()">REBOOT</button>
                </div>
            </div>
        </div>

        <!-- CONTROLS -->
        <div class="controls-area">
            <button class="btn-ctrl" onpointerdown="Game.input('left')" onpointerup="Game.clearInput()" onpointerleave="Game.clearInput()"><i class="ph-bold ph-caret-left"></i></button>
            <button class="btn-ctrl" onclick="Game.input('rotate')"><i class="ph-bold ph-arrow-clockwise"></i></button>
            <button class="btn-ctrl" onpointerdown="Game.input('right')" onpointerup="Game.clearInput()" onpointerleave="Game.clearInput()"><i class="ph-bold ph-caret-right"></i></button>
            <button class="btn-ctrl" onpointerdown="Game.input('down')" onpointerup="Game.clearInput()" onpointerleave="Game.clearInput()"><i class="ph-bold ph-caret-down"></i></button>
            <button class="btn-ctrl btn-lg" onclick="Game.input('drop')">HARD DROP</button>
        </div>

    </div>

<script>
/**
 * TETRA FLUX ENGINE v2.0
 * Mobile-First Responsive Architecture
 */

// --- AUDIO SYSTEM ---
const AudioSys = {
    ctx: null,
    enabled: true,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    toggle() {
        this.enabled = !this.enabled;
        document.getElementById('btn-sfx').classList.toggle('on', this.enabled);
    },
    play(type) {
        if (!this.enabled || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        const now = this.ctx.currentTime;

        // Sound Synthesis Profiles
        switch (type) {
            case 'move':
                osc.type = 'triangle'; osc.frequency.setValueAtTime(220, now);
                gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05); break;
            case 'rotate':
                osc.type = 'square'; osc.frequency.setValueAtTime(440, now);
                gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now); osc.stop(now + 0.1); break;
            case 'drop':
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2); break;
            case 'clear':
                [440, 554, 659, 880].forEach((freq, i) => {
                    const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                    o.connect(g); g.connect(this.ctx.destination); o.type = 'triangle'; o.frequency.value = freq;
                    g.gain.setValueAtTime(0.05, now + i*0.05); g.gain.exponentialRampToValueAtTime(0.001, now + i*0.05 + 0.3);
                    o.start(now + i*0.05); o.stop(now + i*0.05 + 0.3);
                }); break;
            case 'gameover':
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(30, now + 1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 1);
                osc.start(now); osc.stop(now + 1); break;
        }
    }
};

// --- CONFIG ---
const COLS = 10;
const ROWS = 20;
const COLORS = [null, '#ed8796', '#a6da95', '#cba6f7', '#eed49f', '#8aadf4', '#8bd5ca', '#f5a97f'];
const SHAPES = [
    [], [[1,1,0],[0,1,1],[0,0,0]], [[0,2,2],[2,2,0],[0,0,0]], [[0,3,0],[3,3,3],[0,0,0]],
    [[4,4],[4,4]], [[0,0,0,0],[5,5,5,5],[0,0,0,0],[0,0,0,0]], [[6,0,0],[6,6,6],[0,0,0]], [[0,0,7],[7,7,7],[0,0,0]]
];

// --- ENGINE ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    frame: document.getElementById('canvasFrame'),
    viewport: document.getElementById('viewport'),
    ctx: null,
    grid: [],
    piece: null,
    score: 0,
    highScore: parseInt(localStorage.getItem('tetra_high') || '0'),
    
    // Loop Vars
    lastTime: 0,
    dropCounter: 0,
    dropInterval: 1000,
    
    // Input Handling
    inputRepeat: null,
    
    // FX
    particles: [],
    shake: 0,
    running: false,
    vibration: true,
    scale: 20, // Pixels per block

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        // Use ResizeObserver for robust layout changes (orientation change, keyboard open)
        new ResizeObserver(() => this.resize()).observe(this.viewport);
        
        document.addEventListener('keydown', e => {
            if (!this.running) return;
            if (e.key === 'ArrowLeft') this.move(-1);
            else if (e.key === 'ArrowRight') this.move(1);
            else if (e.key === 'ArrowDown') this.drop();
            else if (e.key === 'ArrowUp') this.rotate();
            else if (e.key === ' ') this.hardDrop();
        });

        document.getElementById('high-score').innerText = this.highScore;
        AudioSys.init();
    },

    resize() {
        // Calculate max available dimensions in the viewport container
        const availW = this.viewport.clientWidth;
        const availH = this.viewport.clientHeight;

        // Calculate maximum cell size that fits both dimensions
        // Subtracting small buffer for borders/shadows
        const scaleW = Math.floor((availW - 10) / COLS);
        const scaleH = Math.floor((availH - 10) / ROWS);
        
        // Use the smaller scale to ensure it fits entirely
        this.scale = Math.min(scaleW, scaleH);

        // Apply dimensions
        const cssW = this.scale * COLS;
        const cssH = this.scale * ROWS;
        
        this.frame.style.width = `${cssW}px`;
        this.frame.style.height = `${cssH}px`;
        this.canvas.width = cssW;
        this.canvas.height = cssH;
        
        if (!this.running) this.draw(); // Redraw static if paused/menu
    },

    start() {
        this.grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        this.score = 0;
        this.updateScore(0);
        this.dropInterval = 1000;
        this.particles = [];
        this.running = true;
        this.spawnPiece();
        document.querySelectorAll('.overlay').forEach(el => el.classList.remove('active'));
        if (AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
        this.loop();
    },

    spawnPiece() {
        const type = (Math.random() * 7 | 0) + 1;
        this.piece = {
            matrix: JSON.parse(JSON.stringify(SHAPES[type])), // Deep copy
            pos: {x: (COLS / 2 | 0) - (SHAPES[type][0].length / 2 | 0), y: 0},
            type: type
        };
        if (this.collide(this.grid, this.piece)) this.gameOver();
    },

    // --- GAMEPLAY ---
    drop() {
        this.piece.pos.y++;
        if (this.collide(this.grid, this.piece)) {
            this.piece.pos.y--;
            this.merge();
            this.spawnPiece();
            this.arenaSweep();
            AudioSys.play('drop');
        }
        this.dropCounter = 0;
    },

    hardDrop() {
        while (!this.collide(this.grid, this.piece)) this.piece.pos.y++;
        this.piece.pos.y--;
        this.merge();
        this.spawnPiece();
        this.arenaSweep();
        this.triggerShake(5);
        AudioSys.play('drop');
        if(this.vibration && navigator.vibrate) navigator.vibrate(10);
    },

    move(dir) {
        this.piece.pos.x += dir;
        if (this.collide(this.grid, this.piece)) this.piece.pos.x -= dir;
        else AudioSys.play('move');
    },

    rotate() {
        const pos = this.piece.pos.x;
        let offset = 1;
        this.rotateMatrix(this.piece.matrix);
        while (this.collide(this.grid, this.piece)) {
            this.piece.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > this.piece.matrix[0].length) {
                this.rotateMatrix(this.piece.matrix, -1);
                this.piece.pos.x = pos;
                return;
            }
        }
        AudioSys.play('rotate');
    },

    rotateMatrix(matrix, dir = 1) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        if (dir > 0) matrix.forEach(row => row.reverse());
        else matrix.reverse();
    },

    collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
            }
        }
        return false;
    },

    merge() {
        this.piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) this.grid[y + this.piece.pos.y][x + this.piece.pos.x] = value;
            });
        });
    },

    arenaSweep() {
        let rowCount = 0;
        outer: for (let y = this.grid.length - 1; y > 0; --y) {
            for (let x = 0; x < this.grid[y].length; ++x) {
                if (this.grid[y][x] === 0) continue outer;
            }
            const row = this.grid.splice(y, 1)[0].fill(0);
            this.grid.unshift(row);
            ++y;
            rowCount++;
            for(let i=0; i<10; i++) this.spawnParticle(Math.random() * COLS, y);
        }
        if (rowCount > 0) {
            this.updateScore(rowCount * 10 * rowCount);
            this.dropInterval = Math.max(100, 1000 - (this.score * 0.1));
            AudioSys.play('clear');
            this.triggerShake(rowCount * 3);
            if(this.vibration && navigator.vibrate) navigator.vibrate(50);
        }
    },

    // --- LOOP & DRAW ---
    loop(time = 0) {
        if (!this.running) return;
        const deltaTime = time - this.lastTime;
        this.lastTime = time;
        this.dropCounter += deltaTime;
        if (this.dropCounter > this.dropInterval) this.drop();
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    },

    draw() {
        this.ctx.fillStyle = '#1e1e2e';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        if (this.shake > 0) {
            this.ctx.translate((Math.random()-.5)*this.shake, (Math.random()-.5)*this.shake);
            this.shake *= 0.9;
            if(this.shake < 0.5) this.shake = 0;
        }

        this.drawMatrix(this.grid, {x:0, y:0});

        // Ghost
        let ghostPos = { ...this.piece.pos };
        while (!this.collide(this.grid, { matrix: this.piece.matrix, pos: ghostPos })) ghostPos.y++;
        ghostPos.y--;
        this.ctx.globalAlpha = 0.2;
        this.drawMatrix(this.piece.matrix, ghostPos, true);
        this.ctx.globalAlpha = 1.0;

        this.drawMatrix(this.piece.matrix, this.piece.pos);
        this.updateParticles();
        this.ctx.restore();
    },

    drawMatrix(matrix, offset, ghost = false) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    const cx = (x + offset.x) * this.scale;
                    const cy = (y + offset.y) * this.scale;
                    const size = Math.ceil(this.scale) + 1; // Slight overlap to prevent gaps
                    
                    if(!ghost) {
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = COLORS[value];
                    }
                    this.ctx.fillStyle = COLORS[value];
                    this.ctx.fillRect(cx, cy, size, size);
                    
                    // Bevel effect
                    this.ctx.shadowBlur = 0;
                    this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    this.ctx.fillRect(cx, cy, size, size/4);
                }
            });
        });
    },

    spawnParticle(x, y) {
        this.particles.push({
            x: x * this.scale, y: y * this.scale,
            vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
            life: 1.0, color: '#cdd6f4'
        });
    },

    updateParticles() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life;
            this.ctx.fillRect(p.x, p.y, 4, 4);
            if (p.life <= 0) this.particles.splice(i, 1);
        }
        this.ctx.globalAlpha = 1.0;
    },

    // --- UTILS ---
    updateScore(val) {
        this.score += val;
        document.getElementById('score').innerText = this.score;
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('tetra_high', this.highScore);
            document.getElementById('high-score').innerText = this.highScore;
        }
    },

    gameOver() {
        this.running = false;
        AudioSys.play('gameover');
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('game-over').classList.add('active');
    },

    triggerShake(amount) { this.shake = amount; },
    toggleVib() { this.vibration = !this.vibration; document.getElementById('btn-vib').classList.toggle('on', this.vibration); },

    // Mobile Input Handling
    input(action) {
        if (!this.running) return;
        
        const doAction = () => {
            if (action === 'left') this.move(-1);
            else if (action === 'right') this.move(1);
            else if (action === 'down') this.drop();
            else if (action === 'rotate') this.rotate();
            else if (action === 'drop') this.hardDrop();
        };

        doAction();

        // Repeat for left/right/down holds
        if (action !== 'rotate' && action !== 'drop') {
            this.clearInput();
            this.inputRepeat = setInterval(doAction, 100);
        }
    },

    clearInput() {
        if (this.inputRepeat) {
            clearInterval(this.inputRepeat);
            this.inputRepeat = null;
        }
    }
};

window.onload = () => Game.init();
</script>
</body>
</html>